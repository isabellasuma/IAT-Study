```{r}
#Change to your own directory (where you keep the data file)
dir = 'C:\\Users\\yoav\\Documents\\bigfiles\\qualtrics.iat\\gal.elinor\\raw'
```

```{r}
# Copied from Elad Zlotnick (from here: https://github.com/eladzlot/minnojs-qiat/blob/master/qiat.R)
# Parse csv generated by minnoJS
#
# @param df a data frame
# @param id the column name holding the ids
# @param data the column name holding the data (we assume the data holds an array of unnested objects)
#
# @example
# qiat.parse.quoted(df, 'ResponseId', 'Q_47')
# qiat.parse(df, ResponseId, Q_47)
#
# @returns data frame with parsed data, rows with NA or '' are omitted.
qiat.parse.quoted = function(df, id, data){
  # @TODO does not work?
  # if (is.factor(df[id])) stop(paste0(data, ' column must not be a factor'))
  filteredDF = df[df[,data]!='' & !is.na(df[,data]) ,]
  
  # parse data -> list of data data frames
  csvList = lapply(filteredDF[,data], function(str) tryCatch({
    read.csv(text=str,stringsAsFactors = FALSE)
  },
  error = function(err){
    message('woa there is a malformed csv here')
    return(NA)
  }
  ))
  #browser()
  # add id to each data DF
  mask = which(sapply(csvList,nrow)>0)
  dataPages = mapply(
    function(id, df) cbind(id,df),
    filteredDF[mask,id],
    csvList[mask],
    SIMPLIFY = FALSE
  )
  
  if (!length(dataPages)) { return(data.frame()) }
  
  # concat pages
  do.call(rbind,dataPages)
}

qiat.parse = function(df, id, data){
  qiat.parse.quoted(df, deparse(substitute(id)), deparse(substitute(data)))
}
```

```{r}
###Read your file here.

df = read.csv(paste(dir, 'raceAMP_July+27,+2020_10.19.csv',sep = '\\'))

#Keep only the Q2, which, in our case, is the data from Minno
df <- df[which(grepl('block', df$Q1)),]

```



```{r}
#The escaping in the data sometimes uses "" which we need to change to " for the parsing.
#Note Q3 in my data was the columns that saved the IAT data for each participant. It might have a different name in your data. 
library(kutils)
df$amp <- mgsub(df$Q1, pattern = c('""'), replacement = c('"'))
```

```{r}
#Use Elad's parsing function
df2 <- qiat.parse.quoted(df = df, id='ResponseId', data = 'amp')
```

```{r}
#Sanity check: see the names of the variables.
nrow(df2)
names(df2)
#If successful, these should be:  "id"    "block" "trial" "cond"  "type"  "cat"   "stim"  "resp"  "err"   "rt"    "fb"    
```

```{r}
table(df2$block, exclude=NULL)

#Make sure the 'compatible' trials are indeed what you expected them to be.
table(df2$cond, exclude=NULL)
```

```{r}
df2$prime <- ifelse(grepl('Black', df2$cond), 'black', 
                          ifelse(grepl('White', df2$cond), 'white', NA))
table(df2$prime, exclude=NULL)
df2$rating <- ifelse(grepl('Unpleasant', df2$resp), 0, 
                     ifelse(grepl('Pleasant', df2$resp), 1, NA))
table(df2$rating, exclude=NULL)
  
```

From hereafter, analyze the results however you decide. I will only show the means here. 

```{r}
df2.correct <- df2[which(df2$prime %in% c('black','white')),]
table(df2.correct$rating, exclude=NULL)

library(doBy)
amp.means <- summaryBy(formula = rating ~ id + prime, data = df2.correct)

summaryBy(formula = rating.mean ~ prime, data = amp.means)
```
